# 技术报告文档

## 赵丰

## 基本算法介绍

我们首先按照一定的规则把输入数据按照有向图进行存储，以减少存储空间的开销以及保证每个三角形只数一遍。约定 有 u 的邻居节点有 v 若 d(u) < d(v) 或 当 d(u) = d(v) 时 有 id(u) < id(v) 。其中 d 是节点的 度。

然后我们枚举图中的每条边。对于图的每条边 (u,v)，我们计算 u 和 v 的邻居节点这两个列表相同元素的个数，即为包含(u,v)这条边的三角形个数。 这种方法比较快有两个原因。一个原因是每个三角形只计算一次。另一个原因是我们构造有向图的方法使得每个节点的邻接表长度差不多，有助于大规模并行。

## 并行化设计思路和方法

因为算法要对每个节点进行计数，对不同节点的节数相互独立，因此可以将枚举不同节点这一过程进行并行化。GPU 通常有几百个核心，极大地提高了并行的速度。

### 数据分块
由于 GPU 显存有限，对于较大的图数据。我们采用在 CPU 内存里维护整个数据结构，将数据分块 送入 显存中进行计算的方法。

## 实验结果

对于 `s28.e15.kron.edgelist.bin` 数据集，我们统计出一共有 `199,196,078,202` 个三角形；对于 `s29.e10.kron.edgelist.bin` 数据集，我们统计出一共有 `164,015,236,714` 个三角形。

## 程序代码模块说明

我们的程序分为 `io`, `algorithm` 和 `competition` 三个模块，其中 `io` 处理数据集读入相关的操作； `algorithm` 处理计数算法相关；`competition` 把前两者结合起来，从命令行读入文件名称并输出最终计算结果。

## 程序代码编译说明

在程序根目录使用 `make` 即可在当前文件夹下生成 `nvtc-variant` 可执行文件。


## 程序代码运行使用说明

 `./nvtc-variant -f` 图数据文件

