# 技术报告文档

## 赵丰

## 基本算法介绍

我们首先枚举图中的每个节点。对于图的每个节点 $n$，我们计算包含这个节点的三角形数。为此，我们列举所有与$n$ 相连的节点中度比$n$大的节点 $u$ 和 $v$ 。如果存在度相同的情况, 我们筛选具有比$n$的节点 id 更大的节点。给定 $n, u, v$ 后, 我们测试$(u, v)$ 是否是图的一条边。假设测试两节点之间是否有边相连的时间复杂度是 $d$ （对于邻接表存储的图，$d=\log d(u)$）。可以证明我们采用的算法时间复杂度是 $m^{3/2} d$. 这种方法比较快有两个原因。一个原因是每个三角形只计算一次。另一个原因是对度的排序使得每个$(u,v)$对的枚举不会太多。也就是说，我们节省了总的两节点间是否有边相连检验的次数。

## 并行化设计思路和方法

因为算法要对每个节点进行计数，对不同节点的节数相互独立，因此可以将枚举不同节点这一过程进行并行化。

## 实验结果

对于 `s28.e15.kron.edgelist.bin` 数据集，我们统计出一共有 `199,196,078,202` 个三角形；对于 `s29.e10.kron.edgelist.bin` 数据集，我们统计出一共有 `164,015,236,714` 个三角形。

## 程序代码模块说明

我们的程序分为 `io`, `algorithm` 和 `competition` 三个模块，其中 `io` 处理数据集读入相关的操作； `algorithm` 处理计数算法相关；`competition` 把前两者结合起来，从命令行读入文件名称并输出最终计算结果。

## 程序代码编译说明

在程序根目录使用 `make` 即可在当前文件夹下生成 `nvtc-variant` 可执行文件。


## 程序代码运行使用说明

 `./nvtc-variant -f` 图数据文件

